//pointer's host
.decl HostOfVar(?host:Value, ?var:Var)
.output HostOfVar(IO="file",filename="HostOfVar.csv",delimiter="\t")
.decl HostOfInstanceField(?host:Value, ?basevalue:Value, ?sig:Field)
.output HostOfInstanceField(IO="file",filename="HostOfInstanceField.csv",delimiter="\t")
.decl HostOfStaticField(?host:Value, ?sig:Field)
.output HostOfStaticField(IO="file",filename="HostOfStaticField.csv",delimiter="\t")
.decl HostOfArrayIndex(?host:Value, ?baseValue:Value)
.output HostOfArrayIndex(IO="file",filename="HostOfArrayIndex.csv",delimiter="\t")

//pointer's kind
.decl ContainerKindOfVar(?var:Var, ?containerKind:symbol)
.output ContainerKindOfVar(IO="file",filename="ContainerKindOfVar.csv",delimiter="\t")
.decl ContainerKindOfInstanceField(?basevalue:Value, ?sig:Field, ?containerKind:symbol)
.output ContainerKindOfInstanceField(IO="file",filename="ContainerKindOfInstanceField.csv",delimiter="\t")
.decl ContainerKindOfStaticField(?sig:Field, ?containerKind:symbol)
.output ContainerKindOfStaticField(IO="file",filename="ContainerKindOfStaticField.csv",delimiter="\t")
.decl ContainerKindOfArrayIndex(?baseValue:Value, ?containerKind:symbol)
.output ContainerKindOfArrayIndex(IO="file",filename="ContainerKindOfArrayIndex.csv",delimiter="\t")

//for main pta anslysis
//deal with VarpointsTo:- CollectionCorrelationAssign [type check need here]
.decl CollectionCorrelationAssign(?arg:Var, ?result:Var)
.output CollectionCorrelationAssign(IO="file",filename="CollectionCorrelationAssign.csv",delimiter="\t")
//isRelatedCollectionOutInvoke method call
.decl RelatedCollectionOutMethod(?method:Method)
.output RelatedCollectionOutMethod(IO="file",filename="RelatedCollectionOutMethod.csv",delimiter="\t")
//return assign not passing host&kind
.decl NotPassingReturnAssignFrom(?resutn:Var)
.output NotPassingReturnAssignFrom(IO="file",filename="NotPassingReturnAssignFrom.csv",delimiter="\t")

//[core rule]
//addOutResultToHost method call
.decl OutResultToHost(?result:Var, ?host:Value, ?category:symbol)
.output OutResultToHost(IO="file",filename="OutResultToHost.csv",delimiter="\t")
//executeInArgumentToHost method call
.decl executeInArgumentToHost(?arg:Var, ?host:Value, ?category:symbol)
.output executeInArgumentToHost(IO="file",filename="executeInArgumentToHost.csv",delimiter="\t")
//inArgumentToHost method call
.decl InArgumentToHost(?arg:Var, ?callee:Method, ?index:number, ?host:Value)
.output InArgumentToHost(IO="file",filename="InArgumentToHost.csv",delimiter="\t")

.decl executeInArgumentToHostSource1(?arg:Var, ?host:Value, ?category:symbol)
.output executeInArgumentToHostSource1(IO="file",filename="executeInArgumentToHostSource1.csv",delimiter="\t")
.decl executeInArgumentToHostSource2(?arg:Var, ?host:Value, ?category:symbol)
.output executeInArgumentToHostSource2(IO="file",filename="executeInArgumentToHostSource2.csv",delimiter="\t")
.decl executeInArgumentToHostSource3(?arg:Var, ?host:Value, ?category:symbol)
.output executeInArgumentToHostSource3(IO="file",filename="executeInArgumentToHostSource3.csv",delimiter="\t")
.decl executeInArgumentToHostSource4(?arg:Var, ?host:Value, ?category:symbol)
.output executeInArgumentToHostSource4(IO="file",filename="executeInArgumentToHostSource4.csv",delimiter="\t")


//processCorrelationExtender method call
.decl CorrelationExtenderNeedProcessing(?invocation:MethodInvocation, ?callee:Method)
.output CorrelationExtenderNeedProcessing(IO="file",filename="CorrelationExtenderNeedProcessing.csv",delimiter="\t")
//correlaiton extender relation of vars
.decl ExtendCorrelation(?larger:Var, ?smaller:Var)
.output ExtendCorrelation(IO="file",filename="ExtendCorrelation.csv",delimiter="\t")
//addHostSubsetRelation(, , ,keyset , )
.decl SubsetProcessingKeySet(?larger:Var, ?smaller:Var)
.output SubsetProcessingKeySet(IO="file",filename="SubsetProcessingKeySet.csv",delimiter="\t")
//addHostSubsetRelation(, , , , values )
.decl SubsetProcessingValues(?larger:Var, ?smaller:Var)
.output SubsetProcessingValues(IO="file",filename="SubsetProcessingValues.csv",delimiter="\t")

//temp fule for simpility
//propagateHostAndKind(var, hoseSet, kind) method call
.decl HostAndKindNeedPropagating(?var:Var, ?host:Value, ?containerKind:symbol)
.output HostAndKindNeedPropagating(IO="file",filename="HostAndKindNeedPropagating.csv",delimiter="\t")
//a temp rule for simplicity
.decl HostContainerTypeOfVar(?var:Var, ?containerType:symbol)
.output HostContainerTypeOfVar(IO="file",filename="HostContainerTypeOfVar.csv",delimiter="\t")

//for entrySet
.decl isVirtualVar(?var:Var)
.output isVirtualVar(IO="file",filename="isVirtualVar.csv",delimiter="\t")
.decl EntrySetArgVar(?entrySetClass:Type, ?argVar:Var)
.output EntrySetArgVar(IO="file",filename="EntrySetArgVar.csv",delimiter="\t")

//for arrayInitializer
.decl ArrayInitializerNeedProcessing(?invocation:MethodInvocation, ?constructor:Method, ?index0:number, ?index1:number)
.output ArrayInitializerNeedProcessing(IO="file",filename="ArrayInitializerNeedProcessing.csv",delimiter="\t")
.decl VirtualArrayOfArray(?vitrualArray:Var, ?array:Var)
.output VirtualArrayOfArray(IO="file",filename="VirtualArrayOfArray.csv",delimiter="\t")
.decl VirtualArrayOfCollectionVar(?virtualArray:Var, ?collectionVar:Var)
.output VirtualArrayOfCollectionVar(IO="file",filename="VirtualArrayOfCollectionVar.csv",delimiter="\t")
.decl VirtualArrayAssign(?arrayIndex:Value, ?virtualArray:Var)
.output VirtualArrayAssign(IO="file",filename="VirtualArrayAssign.csv",delimiter="\t")

//for ThisPropagater
.decl CollectionThisPropagate(?base:Var, ?this:Var)
.output CollectionThisPropagate(IO="file",filename="CollectionThisPropagate.csv",delimiter="\t")
.decl SetKindInMap(?kind:symbol)

//generate new host
// HostOfVar(?obj, ?var) :-
//     VarPointsTo(_, ?obj, _, ?var),
//     Value_Type(?obj, ?objType),
//     isHostClass(?objType).

HostOfVar(?obj, ?var) :-
    VarPointsTo(_, ?obj, _, ?var),
    Value_Type(?obj, ?objType),
    isHostClass(?objType),
    (ContainerType(?objType, "MAP");
    ContainerType(?objType, "COLLECTION")).

HostContainerTypeOfVar(?var, ?containerType):-
    VarPointsTo(_, ?obj, _, ?var),
    Value_Type(?obj, ?objType),
    isHostClass(?objType),
    ContainerType(?objType, ?containerType).

//specially handle ProviderList$3
executeInArgumentToHostSource1(?arg, ?obj, "Col-Value"):-
    ?method = "<sun.security.jca.ProviderList$3: java.lang.Object get(int)>",
    isMethod(?method),
    VarPointsTo(_, ?obj, _, _),
    Value_Type(?obj, ?objType),
    isHostClass(?objType),
    ?objType = "sun.security.jca.ProviderList$3",
    ReturnVar(?arg, ?method).
    
// HostAndKindNeedPropagating(?var, ?host, ?containerKind),
ContainerKindOfVar(?var, ?containerKind):-
    HostContainerTypeOfVar(?var, ?containerType),
    ?containerType = "MAP",
    ?containerKind = "MAP_0".
    
// HostAndKindNeedPropagating(?var, ?host, ?containerKind),
ContainerKindOfVar(?var, ?containerKind):-
    HostContainerTypeOfVar(?var, ?containerType),
    ?containerType = "COLLECTION",
    ?containerKind = "COL_0".

//OnNewHost method in tai-e
HostAndKindNeedPropagating(?var, ?host, ?containerKind):-
    HostOfVar(?host, ?var),
    ContainerKindOfVar(?var, ?containerKind).

//propagateHostAndKind method in tai-e
ContainerKindOfVar(?result, ?generatedKind),
HostOfVar(?host, ?result):-
    HostAndKindNeedPropagating(?var, ?host, ?containerKind),
    InvocationActualParamAndBase(-1, ?invocation, ?var),
    AssignReturnValue(?invocation, ?result),
    HostPassers(?containerKind, ?subString, ?generatedKind),
    MethodInvocation_Method(?invocation, ?methodSignature),
    contains(?subString,?methodSignature).

OutResultToHost(?result, ?host, ?category):-
    HostAndKindNeedPropagating(?var, ?host, ?containerKind),
    InvocationActualParamAndBase(-1, ?invocation, ?var),
    AssignReturnValue(?invocation, ?result),
    OutMethodsB(?containerKind, ?subString, ?category),
    MethodInvocation_Method(?invocation, ?methodSignature),
    contains(?subString,?methodSignature).

ContainerKindOfVar(?result, ?generatedKind),
HostOfVar(?host, ?result) :-
    HostAndKindNeedPropagating(?var, ?host, ?containerKind),
    ?containerKind = "COL_0",
    InvocationActualParamAndBase(-1, ?invocation, ?var),
    AssignReturnValue(?invocation, ?result),
    Var_Type(?var, ?baseType),
    isVectorClass(?baseType),
    MethodInvocation_Method(?invocation, ?methodSignature),
    contains("elements(",?methodSignature),
    ?generatedKind = "COL_ITR".

ContainerKindOfVar(?result, ?generatedKind),
HostOfVar(?host, ?result) :-
    HostAndKindNeedPropagating(?var, ?host, ?containerKind),
    ?containerKind = "MAP_0",
    InvocationActualParamAndBase(-1, ?invocation, ?var),
    AssignReturnValue(?invocation, ?result),
    Var_Type(?var, ?baseType),
    isHashtableClass(?baseType),
    MethodInvocation_Method(?invocation, ?methodSignature),
    contains("elements(",?methodSignature),
    ?generatedKind = "MAP_VALUE_ITR".


.decl InArgumentToHostTemp(?actual:Var, ?callee:Method, ?index:number, ?base:Var)
.output InArgumentToHostTemp(IO="file",filename="InArgumentToHostTemp.csv",delimiter="\t")

InArgumentToHostTemp(?actual, ?callee, ?index, ?base):-
    CallGraphEdge(_, ?invocation, _, ?callee),
    ActualParam(?index, ?invocation, ?actual),
    InvocationActualParamAndBase(-1, ?invocation, ?base),
    !UnrelatedInvokes(?invocation).

InArgumentToHost(?actual, ?callee, ?index, ?host):-
    InArgumentToHostTemp(?actual, ?callee, ?index, ?base),
    HostOfVar(?host, ?base).

//inArgumentToHost method in tai-e
executeInArgumentToHostSource2(?arg, ?host, ?category) :-
    InArgumentToHost(?arg, ?callee, ?index, ?host),
    MethodParameterConstraint(?callee, ?index, ?cons, ?category),
    basic.SubtypeOf(?hostType, ?cons),
    Value_Type(?host, ?hostType).

//processCollectionOutInvoke(callsite, callee) <=> callGraphEdge(_, ?invo, _, ?callee) 
.decl OutResultToHostTemp1(?result:Var, ?base:Var, ?category:symbol) //optimize
.output OutResultToHostTemp1(IO="file",filename="OutResultToHostTemp1.csv",delimiter="\t")

.decl OutResultToHostTemp2(?result:Var, ?base:Var, ?category:symbol)//optimize
.output OutResultToHostTemp2(IO="file",filename="OutResultToHostTemp2.csv",delimiter="\t")

.decl HostOfBaseTypeCheck(?host:Value, ?base:Var)
.output HostOfBaseTypeCheck(IO="file",filename="HostOfBaseTypeCheck.csv",delimiter="\t")

OutResultToHost(?result, ?host, ?category):-
    OutResultToHostTemp1(?result, ?base, ?category),
    HostOfVar(?host, ?base).

OutResultToHost(?result, ?host, ?category) :-  
    OutResultToHostTemp2(?result, ?base, ?category),
    HostOfBaseTypeCheck(?host, ?base).

OutResultToHostTemp2(?result, ?base, ?category):-
    CallGraphEdge(_, ?invocation, _, ?callee),
    AssignReturnValue(?invocation, ?result),
    OutMethodsA(?callee, ?category),
    InvocationActualParamAndBase(-1, ?invocation, ?base).

HostOfBaseTypeCheck(?host, ?base):-
    HostOfVar(?host, ?base),
    Var_Type(?base, ?baseType),
    Value_Type(?host, ?hostType),
    basic.SubtypeOf(?hostType, ?baseType).


//optimize purpose
.decl OutResultHostTempOpt1(?result:Var, ?base:Var)
.output OutResultHostTempOpt1(IO="file",filename="OutResultHostTempOpt1.csv",delimiter="\t")

.decl OutResultHostTempOpt2(?result:Var, ?base:Var)
.output OutResultHostTempOpt2(IO="file",filename="OutResultHostTempOpt2.csv",delimiter="\t")

.decl OutResultHostTempOpt3(?result:Var, ?base:Var)
.output OutResultHostTempOpt3(IO="file",filename="OutResultHostTempOpt3.csv",delimiter="\t")

.decl OutResultHostTempOpt4(?result:Var, ?base:Var)
.output OutResultHostTempOpt4(IO="file",filename="OutResultHostTempOpt4.csv",delimiter="\t")

.decl OutResultHostTempOpt5(?result:Var, ?base:Var)
.output OutResultHostTempOpt5(IO="file",filename="OutResultHostTempOpt5.csv",delimiter="\t")


OutResultToHost(?result, ?host, ?category):-
    OutResultToHostTemp1(?result, ?base, ?category),
    HostOfVar(?host, ?base).

OutResultHostTempOpt1(?result, ?base) :-
    CallGraphEdge(_, ?invocation, _, ?callee),
    AssignReturnValue(?invocation, ?result),
    InvocationActualParamAndBase(-1, ?invocation, ?base),
    Method_DeclaringType(?callee, ?classType),
    isMapEntryClass(?classType),
    contains("getValue(",?callee).
OutResultToHostTemp1(?result, ?base, "Map-Value") :-
    OutResultHostTempOpt1(?result, ?base),
    ContainerKindOfVar(?base, "MAP_ENTRY").


OutResultHostTempOpt2(?result, ?base) :-
    CallGraphEdge(_, ?invocation, _, ?callee),
    AssignReturnValue(?invocation, ?result),
    InvocationActualParamAndBase(-1, ?invocation, ?base),
    Method_DeclaringType(?callee, ?classType),
    isMapEntryClass(?classType),
    contains("getKey(",?callee).
OutResultToHostTemp1(?result, ?base, "Map-Key") :-
    OutResultHostTempOpt2(?result, ?base),
    ContainerKindOfVar(?base, "MAP_ENTRY").


OutResultHostTempOpt3(?result, ?base) :-
    CallGraphEdge(_, ?invocation, _, ?callee),
    AssignReturnValue(?invocation, ?result),
    InvocationActualParamAndBase(-1, ?invocation, ?base),
    Method_DeclaringType(?callee, ?classType),
    IteratorClass(?classType),
    (contains("next()",?callee);
    contains("previous()",?callee)).
OutResultToHostTemp1(?result, ?base, "Map-Value") :-
    OutResultHostTempOpt3(?result, ?base),
    ContainerKindOfVar(?base, "MAP_VALUE_ITR").

OutResultHostTempOpt4(?result, ?base) :-
    CallGraphEdge(_, ?invocation, _, ?callee),
    AssignReturnValue(?invocation, ?result),
    InvocationActualParamAndBase(-1, ?invocation, ?base),
    Method_DeclaringType(?callee, ?classType),
    IteratorClass(?classType),
    (contains("next()",?callee);
    contains("previous()",?callee)).
OutResultToHostTemp1(?result, ?base, "Map-Key") :-
    OutResultHostTempOpt4(?result, ?base),
    ContainerKindOfVar(?base, "MAP_KEY_ITR").
OutResultToHostTemp1(?result, ?base, "Col-Value") :-
    OutResultHostTempOpt4(?result, ?base),
    ContainerKindOfVar(?base, "COL_ITR").


OutResultHostTempOpt5(?result, ?base) :-
    CallGraphEdge(_, ?invocation, _, ?callee),
    AssignReturnValue(?invocation, ?result),
    InvocationActualParamAndBase(-1, ?invocation, ?base),
    Method_DeclaringType(?callee, ?classType),
    isEnumerationClass(?classType),
    contains("nextElement()",?callee).
OutResultToHostTemp1(?result, ?base, "Map-Value") :-   
    OutResultHostTempOpt5(?result, ?base),
    ContainerKindOfVar(?base, "MAP_VALUE_ITR").
OutResultToHostTemp1(?result, ?base, "Map-Key") :-
    OutResultHostTempOpt5(?result, ?base),
    ContainerKindOfVar(?base, "MAP_KEY_ITR").    
OutResultToHostTemp1(?result, ?base, "Col-Value") :-
    OutResultHostTempOpt5(?result, ?base),
    ContainerKindOfVar(?base, "COL_ITR").    
// OutResultToHostTemp1(?result, ?base, "Col-Value") :-
//     OutResultHostTempOpt5(?result, ?base),
//     ContainerKindOfVar(?base, "MAP_ENTRY_ITR").

//addSuperHost method && propagateArgumentsToSuperHosts method && executeInArgumentToHost method
//in tai-e : each added entry (super, arg ,category) -> executeInArgumentToHost(super, arg ,category) and add entry (super'super, arg ,category)

CollectionCorrelationAssign(?arg, ?result) :-
    executeInArgumentToHost(?arg, ?host, ?category),
    OutResultToHost(?result, ?host, ?category).

//VPT & host & kind pass for collection-correlation assign
HostOfVar(?host, ?result):-
    CollectionCorrelationAssign(?arg, ?result),
    HostOfVar(?host, ?arg).
ContainerKindOfVar(?result, ?kind):-
    CollectionCorrelationAssign(?arg, ?result),
    ContainerKindOfVar(?arg, ?kind).
//may need optimize
VarPointsTo("<<immutable-hcontext>>", ?value, "<<immutable-context>>", ?result):-
    CollectionCorrelationAssign(?arg, ?result),
    Var_Type(?result, ?allowedType),
    VarPointsTo(_, ?value, _, ?arg),
    Value_Type(?value, ?type),
    basic.SubtypeOf(?type, ?allowedType).

//shouldStopEdge in tai-e
NotPassingReturnAssignFrom(?return):-
    ReturnVar(?return, ?method),
    Method_DeclaringType(?method, ?classType),
    isHostClass(?classType),
    isHashtableClass(?classType),
    (contains("elements()",?method);
    contains("keys()", ?method)).

NotPassingReturnAssignFrom(?return):-
    ReturnVar(?return, ?method),
    Method_DeclaringType(?method, ?classType),
    isHostClass(?classType),
    isVectorClass(?classType),
    contains("elements()", ?method).
    
NotPassingReturnAssignFrom(?return):-
    ReturnVar(?return, ?method),
    Method_DeclaringType(?method, ?classType),
    isHostClass(?classType),
    (contains("iterator(",?method);
    contains("entrySet()",?method);
    contains("keySet()",?method);
    contains("KeySet()",?method);
    contains("values()",?method);
    contains("Entry(",?method);
    contains("Iterator(",?method)).

// logic about collection in main pta analysis
RelatedCollectionOutMethod(?method):-   
    OutMethodsA(?method, _).
RelatedCollectionOutMethod(?method):-
    Method_DeclaringType(?method, ?classType),
    isMapEntryClass(?classType),
    (contains("getValue(", ?method);
    contains("getKey(", ?method)).

RelatedCollectionOutMethod(?method):-
    Method_DeclaringType(?method, ?classType),
    IteratorClass(?classType),
    (contains("next()", ?method);
    contains("previous()", ?method)),
    HostClassInnerClass(?classType).

RelatedCollectionOutMethod(?method):-
    Method_DeclaringType(?method, ?classType),
    isEnumerationClass(?classType),
    contains("nextElement()", ?method),
    HostClassInnerClass(?classType).

#ifdef TAMIFLEX
//tamiflex return var
HostOfVar(?host, ?to):-
  OptInterproceduralAssign(_, ?to, _, ?from),
  HostOfVar(?host, ?from),
  !NotPassingReturnAssignFrom(?from).
ContainerKindOfVar(?to, ?kind):-
  OptInterproceduralAssign(_, ?to, _, ?from),
  ContainerKindOfVar(?from, ?kind),
  !NotPassingReturnAssignFrom(?from).

//tamiflex param assign
HostOfVar(?host, ?to):-
  TamiflexInvocationArgumentArrayValue(_, ?to, _, ?basevalue),
  HostOfArrayIndex(?host, ?basevalue).
ContainerKindOfVar(?to, ?kind):-
  TamiflexInvocationArgumentArrayValue(_, ?to, _, ?basevalue),
  ContainerKindOfArrayIndex(?basevalue, ?kind).
#endif //TAMIFLEX


//plugin.OnNewCallEdge method in tai-e
CorrelationExtenderNeedProcessing(?invocation, ?callee):-
    CallGraphEdge(_, ?invocation, _, ?callee),
    CorrelationExtender(?callee, _, _).
ArrayInitializerNeedProcessing(?invocation, ?methodSignature, ?index0, ?index1):-
    MethodInvocation_Method(?invocation, ?methodSignature),
    ArrayInitializer(?methodSignature, ?index0, ?index1).

//for entryset
//Stmtprocessor:new
VarPointsTo("<<immutable-hcontext>>", ?heapValue, "<<immutable-context>>", ?arg):-
    (AssignContextInsensitiveHeapAllocation(?heapValue, _, ?inmethod);
    AssignNormalHeapAllocation(?heapValue, _, ?inmethod)),
    Value_Type(?heapValue, ?type),
    isMapEntryClass(?type),
    Method_DeclaringType(?inmethod, ?classType),
    EntrySetClass(?entrySetClass, ?classType),
    EntrySetArgVar(?entrySetClass, ?arg).

//onStart
EntrySetArgVar(?entrySetClass, ?var),
isVirtualVar(?var),
PlusVar(?var, "null", "java.lang.Object"):-
    EntrySetClass(?entrySetClass, _),
    ?var = cat(?entrySetClass, "/arg").

// //the host <=> var relation first generated in onNewPointsToSet, maybe latter generated HostOfVar do not need to do certain things
//original rule to generate hosts
executeInArgumentToHostSource3(?arg, ?obj, "Col-Value"):-
    VarPointsTo(_, ?obj, _, _),
    Value_Type(?obj, ?objType),
    isHostClass(?objType),
    EntrySetArgVar(?objType, ?arg).

//this var propagate
//optimize here
.decl CollectionThisPropagateTemp(?base:Var, ?this:Var)
.output CollectionThisPropagateTemp(IO="file",filename="CollectionThisPropagateTemp.csv",delimiter="\t")

SetKindInMap("MAP_KEY_SET").
SetKindInMap("MAP_VALUES").
SetKindInMap("MAP_ENTRY_SET").

HostOfVar(?host, ?this):-
    CollectionThisPropagate(?base, ?this),
    HostOfVar(?host, ?base).

ContainerKindOfVar(?this,?kind),
CollectionThisPropagate(?base,?this):-
    CollectionThisPropagateTemp(?base, ?this),
    ContainerKindOfVar(?base, ?kind),
    SetKindInMap(?kind).

CollectionThisPropagateTemp(?base, ?this):-
    CallGraphEdge(_, ?invocation, _, ?callee),
    ThisVar(?callee, ?this),
    InvocationActualParamAndBase(-1, ?invocation, ?base).

ContainerKindOfVar(?this,?kind),
CollectionThisPropagate(?base,?this):-
    CallGraphEdge(_, ?invocation, _, ?callee),
    InvocationActualParamAndBase(-1, ?invocation, ?base),
    ThisVar(?callee, ?this),
    Method_DeclaringType(?callee, ?class),
    ContainerKindOfVar(?base, ?kind),
    ?class = "java.util.Hashtable$Enumerator".

#ifdef TAMIFLEX
//tamiflex base->this
ContainerKindOfVar(?this,?kind),
CollectionThisPropagate(?base,?this):-
    Tamiflex_Invoke(_, ?invocation, ?callee),
    ! Method_Modifier("static", ?callee),
    ActualParam(0, ?invocation, ?base),
    ThisVar(?callee, ?this),
    ContainerKindOfVar(?base, ?kind),
    SetKindInMap(?kind).

ContainerKindOfVar(?this,?kind),
CollectionThisPropagate(?base,?this):-
    Tamiflex_Invoke(_, ?invocation, ?callee),
    ! Method_Modifier("static", ?callee),
    ActualParam(0, ?invocation, ?base),
    ThisVar(?callee, ?this),
    ContainerKindOfVar(?base, ?kind),
    Method_DeclaringType(?callee, ?class),
    ?class = "java.util.Hashtable$Enumerator".
#endif //TAMIFLEX

//processArrayInitializer method in tai-e
VirtualArrayOfCollectionVar(?var, ?collectionVar),
VirtualArrayOfArray(?var, ?arrayVar),
isVirtualVar(?var),
PlusVar(?var, ?caller, ?elementType):-
    ArrayInitializerNeedProcessing(?invocation, ?constructor, ?index0, ?index1),
    InvocationActualParamAndBase(?index0, ?invocation, ?arrayVar),
    InvocationActualParamAndBase(?index1, ?invocation, ?collectionVar),
    Var_Type(?arrayVar, ?arrayVarType),
    isArrayType(?arrayVarType),
    ComponentType(?arrayVarType, ?elementType),
    ?var = cat(cat(cat(?invocation, "->"), ?constructor), "/virtualArray"),
    Instruction_Method(?invocation, ?caller).

executeInArgumentToHostSource4(?var, ?host, "Col-Value"):-
    VirtualArrayOfCollectionVar(?var, ?collectionVar),
    HostOfVar(?host, ?collectionVar).

VirtualArrayAssign(?arrayIndex, ?var):-
    VirtualArrayOfArray(?var, ?arrayVar),
    VarPointsTo(_,?arrayIndex,_,?arrayVar).

HostOfVar(?host, ?virtualArray):-
    VirtualArrayAssign(?arrayIndex, ?virtualArray),
    HostOfArrayIndex(?host, ?arrayIndex).
ContainerKindOfVar(?virtualArray, ?kind):-
    VirtualArrayAssign(?arrayIndex, ?virtualArray),
    ContainerKindOfArrayIndex(?arrayIndex, ?kind).
VarPointsTo("<<immutable-hcontext>>", ?value, "<<immutable-context>>", ?virtualArray):-
    VirtualArrayAssign(?arrayIndex, ?virtualArray),
    ArrayIndexPointsTo(_, ?value, _, ?arrayIndex).

//processCorrelationExtender method in tai-e
ExtendCorrelation(?arg1, ?arg2):-
    CorrelationExtenderNeedProcessing(?invocation, ?callee),
    CorrelationExtender(?callee, ?index0, ?index1),
    InvocationActualParamAndBase(-1, ?invocation, ?base),
    Instruction_Method(?invocation, ?caller),
    !MethodFormalParamAndThis(-1, ?caller, ?base),
    InvocationActualParamAndBase(?index0, ?invocation, ?arg1),
    InvocationActualParamAndBase(?index1, ?invocation, ?arg2).

SubsetProcessingKeySet(?larger, ?smaller):-
    ExtendCorrelation(?larger, ?smaller),
    ContainerKindOfVar(?smaller, "MAP_KEY_SET").
SubsetProcessingValues(?larger, ?smaller):-
    ExtendCorrelation(?larger, ?smaller),
    ContainerKindOfVar(?smaller, "MAP_VALUES").

//addHostSubsetRelation method
executeInArgumentToHost(?arg, ?host, ?category):-
    executeInArgumentToHostSource1(?arg, ?host, ?category).

executeInArgumentToHost(?arg, ?host, ?category):-
    executeInArgumentToHostSource2(?arg, ?host, ?category).

executeInArgumentToHost(?arg, ?host, ?category):-
    executeInArgumentToHostSource3(?arg, ?host, ?category).

executeInArgumentToHost(?arg, ?host, ?category):-
    executeInArgumentToHostSource4(?arg, ?host, ?category).

executeInArgumentToHost(?arg, ?largerhost, ?category):-
    ExtendCorrelation(?larger, ?smaller),
    HostOfVar(?largerhost, ?larger),
    HostOfVar(?smallerhost, ?smaller),
    executeInArgumentToHost(?arg, ?smallerhost, ?category).

executeInArgumentToHost(?arg, ?largerhost, "Col-Value"):-
    SubsetProcessingKeySet(?larger, ?smaller),
    HostOfVar(?largerhost, ?larger),
    HostOfVar(?smallerhost, ?smaller),
    executeInArgumentToHost(?arg, ?smallerhost, "Map-Key").

executeInArgumentToHost(?arg, ?largerhost, "Col-Value"):-
    SubsetProcessingValues(?larger, ?smaller),
    HostOfVar(?largerhost, ?larger),
    HostOfVar(?smallerhost, ?smaller),
    executeInArgumentToHost(?arg, ?smallerhost, "Map-Value").
